<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Luky116 Blog</title>
    <link>http://luky116.github.io/</link>
    <description>Recent content on Luky116 Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 25 Jul 2020 17:00:17 +0800</lastBuildDate>
    
	<atom:link href="http://luky116.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Mockito学习(1) - 快速入门</title>
      <link>http://luky116.github.io/post/mockito%E5%AD%A6%E4%B9%A01-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sat, 25 Jul 2020 17:00:17 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/mockito%E5%AD%A6%E4%B9%A01-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid>
      <description>Mockito是一个模拟测试框架，可以让你用优雅，简洁的接口写出漂亮的单元测试。Mockito可以让单元测试易于可读，产生简洁的校验错误。 1</description>
    </item>
    
    <item>
      <title>Guava 快速入门</title>
      <link>http://luky116.github.io/post/guava%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link>
      <pubDate>Fri, 05 Jun 2020 17:00:17 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/guava%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid>
      <description>Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符</description>
    </item>
    
    <item>
      <title>23种设计模式(13) - 责任链模式</title>
      <link>http://luky116.github.io/post/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F-/</link>
      <pubDate>Sun, 24 May 2020 10:22:17 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F13-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F-/</guid>
      <description>23种设计模式(13) - 责任链模式 1、定义 使多个对象都有机会处理请求，从而避免请求的发送者和接受者质检的耦合关系。将这个接收对象连成一条链，</description>
    </item>
    
    <item>
      <title>23种设计模式(4) - 适配器模式</title>
      <link>http://luky116.github.io/post/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-/</link>
      <pubDate>Fri, 22 May 2020 10:22:17 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-/</guid>
      <description>1、定义 将一个接口转换成客户希望的另一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类，可以一起工作。 2、UML图 3、</description>
    </item>
    
    <item>
      <title>23种设计模式(3) - 创建者模式</title>
      <link>http://luky116.github.io/post/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3-%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F-/</link>
      <pubDate>Mon, 18 May 2020 10:22:17 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3-%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F-/</guid>
      <description>1、定义 将一个复杂对象的创建和他的表示分离，使用同样的创建过程可以创建不同的表示（类的不同属性的实例）。 2、UML 图 3、组成 产品类（Prod</description>
    </item>
    
    <item>
      <title>23种设计模式(1) - 工厂方法模式</title>
      <link>http://luky116.github.io/post/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 12 May 2020 10:22:17 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>1、定义 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 2、举例 有一个Animal接口，有两个类</description>
    </item>
    
    <item>
      <title>23种设计模式(0) - 设计模式六大原则</title>
      <link>http://luky116.github.io/post/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sun, 10 May 2020 10:22:17 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</guid>
      <description>1、单一职责原则 就一个类而言，应该只有一个引起它变化的原因。意思是，一个类应该实现单一的职责，如果功能太多就应该将类拆分。 2、开放-封闭原则</description>
    </item>
    
    <item>
      <title>关于设计模式</title>
      <link>http://luky116.github.io/post/0%E5%85%B3%E4%BA%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 08 May 2020 10:22:17 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/0%E5%85%B3%E4%BA%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>设计模式（Design pattern）`代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。使用设计模式可以帮助我们重用代码，让我</description>
    </item>
    
    <item>
      <title>《代码整洁之道》整理</title>
      <link>http://luky116.github.io/post/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E6%95%B4%E7%90%86/</link>
      <pubDate>Sun, 18 Aug 2019 14:00:07 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E6%95%B4%E7%90%86/</guid>
      <description>1、命名篇 避免使用误导性的命名，比如是List类型变量才会命名为accountList；不使用小写的字母L和大写的字母O来命名变量，因为他们</description>
    </item>
    
    <item>
      <title>MySQL查询优化 关联查询</title>
      <link>http://luky116.github.io/post/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Sat, 10 Aug 2019 14:04:09 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2/</guid>
      <description>1. 关联查询执行流程 MySQL执行关联查询的策略很简单，他会从一个表中循环取出单条数据，然后用该条数据到下一个表中寻找匹配的行，然后回溯到上一</description>
    </item>
    
    <item>
      <title>Java多线程学习之ThreadLocal源码分析</title>
      <link>http://luky116.github.io/post/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B9%8Bthreadlocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 20 Nov 2017 14:09:22 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B9%8Bthreadlocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>0、概述 ThreadLocal，即线程本地变量。它是将变量绑定到特定的线程上的“入口“，使每个线程都拥有改变量的一个拷贝，各线程相同变量间互</description>
    </item>
    
    <item>
      <title>Java多线程学习之synchronized总结</title>
      <link>http://luky116.github.io/post/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B9%8Bsynchronized%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 19 Nov 2017 14:14:42 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B9%8Bsynchronized%E6%80%BB%E7%BB%93/</guid>
      <description>0、概述 synchronized是Java提供的内置的锁机制，来实现代对码块的同步访问，称为内置锁（Intrinsic Lock） 。内置锁包括</description>
    </item>
    
    <item>
      <title>Java多线程学习之线程的取消与中断机制</title>
      <link>http://luky116.github.io/post/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88%E4%B8%8E%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sat, 18 Nov 2017 14:16:39 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88%E4%B8%8E%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/</guid>
      <description>任务和线程的启动很容易。在大多数情况下我们都会让他们运行直到结束，或是让他们自行停止。但是，有时我们希望提前结束任务或是线程，可能是因为用户</description>
    </item>
    
    <item>
      <title>Java多线程学习之Lock与ReentranLock详解</title>
      <link>http://luky116.github.io/post/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B9%8Block%E4%B8%8Ereentranlock%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 18 Nov 2017 14:09:22 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B9%8Block%E4%B8%8Ereentranlock%E8%AF%A6%E8%A7%A3/</guid>
      <description>synchronized 是内置锁，而Lock 接口定义的是显示锁，Lock 提供了一种可重入的、可轮询的、定时的以及可中断的锁获取操作。 ReenTranLock实现了</description>
    </item>
    
    <item>
      <title>Java多线程学习之线程池源码详解</title>
      <link>http://luky116.github.io/post/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 14 Nov 2017 14:09:22 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/</guid>
      <description>0、使用线程池的必要性 在生产环境中，如果为每个任务分配一个线程，会造成许多问题： **线程生命周期的开销非常高。**线程的创建和销毁都要付出代</description>
    </item>
    
    <item>
      <title>MyBatis一、二级缓存和自定义缓存</title>
      <link>http://luky116.github.io/post/mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%93%E5%AD%98/</link>
      <pubDate>Wed, 18 Oct 2017 14:29:03 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/mybatis%E4%B8%80%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%93%E5%AD%98/</guid>
      <description>1、一级缓存 MyBatis **默认开启了一级缓存**，一级缓存是在SqlSession 层面进行缓存的。即，同一个SqlSession ，多次调用同一个Ma</description>
    </item>
    
    <item>
      <title>Spring依赖注入的方式</title>
      <link>http://luky116.github.io/post/spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Wed, 11 Oct 2017 14:29:03 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F/</guid>
      <description>1、依赖注入（DI） 的重要性 如果直接在代码里面实例化一个对象，会使代码的耦合度大，使代码难以测试，难以复用，难以理解。通过DI，对象的依赖关</description>
    </item>
    
    <item>
      <title>Spring高级依赖注入方式</title>
      <link>http://luky116.github.io/post/spring%E9%AB%98%E7%BA%A7%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Wed, 11 Oct 2017 14:29:03 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/spring%E9%AB%98%E7%BA%A7%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</guid>
      <description>1、处理自动装配的歧义性 1.1 标记首选的bean 使用@Primary 来说明一个bean是首选的。 1 2 3 @Component @Primary public class GuoRongCD implements CompactDisc {} 或是 1 2 3 4 5 6 7 @Bean @Primary public MediaPlayer</description>
    </item>
    
    <item>
      <title>Java多线程学习之wait、notify和notifyAll详解</title>
      <link>http://luky116.github.io/post/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B9%8Bwaitnotify%E5%92%8Cnotifyall%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 06 Oct 2017 14:29:03 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B9%8Bwaitnotify%E5%92%8Cnotifyall%E8%AF%A6%E8%A7%A3/</guid>
      <description>1、wait()、notify/notifyAll() 方法是Object的本地final方法，无法被重写。 2、wait()使当前线程阻塞，前</description>
    </item>
    
    <item>
      <title>Java中Comparable和Comparator比较</title>
      <link>http://luky116.github.io/post/java%E4%B8%ADcomparable%E5%92%8Ccomparator%E6%AF%94%E8%BE%83/</link>
      <pubDate>Mon, 02 Oct 2017 14:29:03 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/java%E4%B8%ADcomparable%E5%92%8Ccomparator%E6%AF%94%E8%BE%83/</guid>
      <description>1、Comparable 介绍 Comparable 是一个排序接口，如果一个类实现了该接口，说明该类本身是可以进行排序的。注意，除了基本数据类型（八大基本数据类型</description>
    </item>
    
    <item>
      <title>Java中断机制(interrupt))</title>
      <link>http://luky116.github.io/post/java%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6interrupt/</link>
      <pubDate>Fri, 29 Sep 2017 14:43:00 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/java%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6interrupt/</guid>
      <description>中断线程 在 run() 方法中，如果语句执行到了最会一句，或是遇到 return 方法，或是方法中出现了没有被捕获的异常，run() 方法将会执行结束。在java中，T</description>
    </item>
    
    <item>
      <title>垃圾回收和内存分配策略</title>
      <link>http://luky116.github.io/post/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</link>
      <pubDate>Sun, 24 Sep 2017 14:43:00 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</guid>
      <description>垃圾回收和内存分配策略 由于程序计数器、虚拟机栈、本地方法栈随线程而生，随线程而灭一般的垃圾回收指Java 堆和方法区出的内存回收。 1 如何判断对</description>
    </item>
    
    <item>
      <title>Java虚拟机的类加载机制</title>
      <link>http://luky116.github.io/post/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Fri, 15 Sep 2017 14:43:00 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid>
      <description>Java 虚拟机的类加载机制 关于类加载机制： ​ 虚拟机把描述类的数据从Class 文件加载到内存，并对数据进行效验、转换解析和初始化，最终 形成可以被虚拟</description>
    </item>
    
    <item>
      <title>MySQL索引</title>
      <link>http://luky116.github.io/post/mysql%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Wed, 30 Aug 2017 14:43:00 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/mysql%E7%B4%A2%E5%BC%95/</guid>
      <description>1、为什么会有索引 当数据保存在磁盘介质上时，它是作为数据库存放的，每条数据是作为一个整体存储的。磁盘存放数据的数据结构类似于链表，即，每个节</description>
    </item>
    
    <item>
      <title>数据库三范式</title>
      <link>http://luky116.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F/</link>
      <pubDate>Tue, 29 Aug 2017 14:43:00 +0800</pubDate>
      
      <guid>http://luky116.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F/</guid>
      <description>1、前言 数据库关系模式可分为第一范式（1NF），第二范式（2NF），第三范式（3NF）和Boyce-Codd范式（BCNF）。这几个规范要求</description>
    </item>
    
  </channel>
</rss>